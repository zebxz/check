1:27 ........we studied devops with aws, linux and k8  9058901010  2400

ubuntu@master:~$ kubectl get po 
no resources found in the default namespace    ****************************** this is set to my current context , its my current name space

ubuntu@master:~$ kubectl get po -n dev    ............**************** we can see some pod that v been  deployed in the dev namespace
NAME      READY      STATUS       RESTARTS      AGE
hello     1/1       running         0            8m38s
webapp    1/1       running         0             12s

 WHEN I RUN  kubectl get po  i want it TO LIST THE pods in my (dev namespace) in the default namespace
----
at the moment the default namespace is my current namespace, thats why when i execute  kubectl get po , it says no resources in the default namespace bt once i run :
kubectl config set-context --current --namespace=dev       **v modified my current workspace such that if i execute  kubectl get po it lists d pods in the dev namespace

ubuntu@master:~$ kubectl get po     ....******************************  kubectl get po it lists d pods in the dev namespace, so d dev namespace has become my current  
NAME      READY      STATUS       RESTARTS      AGE                                                                                    namespace
hello     1/1       running         0            8m38s
webapp    1/1       running         0             12s

**************originally, it was the default namespace that was the current namspace but i v changed my context to dev


########################### MORE PODS COMMANDS ............7:25
kubectl get all
kubectl get events
kubectl delete po (podname)
kubectl delete all --all 
kubectl delete all --all -n dev     
kubectl delete pod --all                                                                                               interpretin , creatin &mangin d pod 
kubectl get pods                               Anotation is a metadata info abt ur pod that is set by d sys/k8 service n it is what d sys wil understan when it comes to
kubectl get pods -o yaml   ...   will present the pod in that are runnin in our clustera yml file, we can see annotation,bt when we made d file to create d pod der was no anotation
kubectl get pods --show-labels
kubectl get pods -o wide           **************** gives more inf abt the pods
kubectl get pods -o wide --show-labels
kubectl get node
kubectl get node -o wide    *************** we see d nodes we v , the k8 version, the kernel version and the runtime which is containerd and not docker .(tk note)
kubectl delete node node5   ******************* to delete node5

in docker we run: docker inspect  to get more info abt the container
kubectl  describe pod <podName>      *********to get more info abt the pod 
kubectl  describe pod <podName> -n <namespace>

16:10:00
kubectl run app --image=mylandmarktech/hello --port=80              ... dis wil deploy a pod called hello


hello.yml       >>>>>>>>>>>>>>>>   using the declaractive approach  ....  (20:50) *************WE want to creat/deploy an appl called pod (i think he meant hello)
=========   kams     ........ this is the acronmy, it stands for kind,apiversion, metadata, spec
kind: Pod   
apiVersion: v1    
metadata: 
   name: hello
   labels:
     app: hello     
spec:
   containers:
   - name: hello   
     image: mylandmarktech/hello  
     ports:                                          *********with dis definition file, we can deploy our application ,,,
     - containerPort: 80      #######  we did nt declacre our  namespace so.. but what is our current namespace???/ wher wil d app wil be deployed (dev namespace bc we made)
                                                                                                        it our default namespace by modifing it above
***********************************************************************************************************************************************************
kubectl api-resources   *********** to get the apiresources for our pod,, we can see so many api resources , ...
kubectl api-resources | grep pod      ....  so to specify n grep for pod , we see we can either call it pods or po and the apiversion is v1
******************************************************************************************

########## to deploy the manifestfile  we cfeated above 
mkdir manifests
vi manifest/hello.yml  and paste the file 
kubectl apply -f manifest

ubuntu@master:~$ kubectl apply -f manifest
error: unable to edcode "manifest/hello.yml:json cannot unmarshla array into 
       GO struct field ObjectMeta.metadata.labels of type map[string}string

************************so he vi again into the file and saw taht he listed metadata bt its suppose to be a dictionary not a list 
    metadata: 
   name: hello
   labels:
     -app: hello     .....so he corrected it to  app: hello
  
ubuntu@master:~$ kubectl apply -f manifest
pod/hello created
ubuntu@master:~$ kubectl get all
NAME            READY       STATUS      RESTARTS       AGE
Pod/hello         1/1        Running     0              18s               *********** the pod is running bt hw do we discover the pod in our clutser?  service discovery


ServiceDicovery:
==============
*********the first service type is:
ClusterIP is the default kubernetes service type that support
communication within the cluster. 
************** to communicate within our cluster, we will use a clusterip service type                                             LEts cal it 
e.g we v the hello app on node1,& d webapp on node9 ,, for webapp to comm with hekllo app, we v to create a service for our helloapp, helloSVC n D sevice type is clusterip
if u look at the pod we created in the definition file , we v a label; app is mapped to hello
POD=labels:
  app: hello            *******........... app is mapped to hello
Serice = selectors:  
   app: hello  

********************* for a service to deiscove rany pod, its going to be using labels, so what is the label of the pod
so we v labelas n we also v selectors...  so ders a label that says app is mappsed to label , its under the pod, so we v pot label
under service, we ar goin to v sevice selectors
in my k8 cluster der wil b many sevices,  hw wil the servoice be able to identify this pod,, it nids to create a selector that matches this pod like that so ... (hello)
#########so in the hello service (helloSVC), ther will be a selector, n the selector s saying app, bc this selector depends on the pod, so in the app pod, we v a label n app
is mapped to hello 
*******************
webService                                 hello
hellSVC                                    labels
selector                                   app:hello
app:hello               d app has a container port  80
ClusteriP                 
targetport80       when u create a service, wher u v the container port will be represented by the target port, so d servixe is targeting port80
 so the webapp wants to com with thw helloapp , d webbapp can nt comm with d helloapp directly in the cluster, its nt supported in k8, so hw is the com to be established?,
via service discovery..

lets assume the webapp pod has its own label:
webapp
app:web
8080           container port
so the webapp wants to com with thw helloapp, the comm is goin to be est via the helloSVC ,webapp is goin to route traffic to the service that is controlling the hello pod
once it does that, then the service will comm with the pod in this order
this is service within the cluster
in k8 we can create a service and we will look at theta very soon 

lets talk abt k8 SVC:  .........,30:52

kubernetes Service:
  In Kubernetes Service makes our pods accessible/discoverable 
  within the cluster or exposing them outside  the cluster.
  service will identify pods using it's labels And Selector. 
  Whenever we create a service a ClusterIP (virtual IP) Address 
  will be allocated for that serivce and DNS entry will be created for that IP.
  So internally we can access using service name(DNS).

2174  2409
########CREATING SERVICE FOR HELLoAPP
hellosvc.yml  
=========== kams    ..... .....acronmy
kind: Service  
apiVersion: v1  
metadata:
  name: hellosvc    ... i can assign a servicename
spec:
   type: ClusterIP    ...service type
   selector:   ... hw wil the service be identified or hw will it identify the app that its suppose to route traffic to ., it wil be based on the label of the appl
      app: hello     .... its hello bc refferring to the manifest/identifictaion file we used to create the hello pod above ,, the label says app:hello
   ports:                                                                              therefore, my selector will be hello, so it can route traffic to the appl
   - port: 80           ......service port  bc our container port in the manifest file is we used to create the pod is 80
     targetPort: 80        

#############we can create a new file or add it to the existing manifest file we already have  by ,, (--- to seperate the files)

******************************************************************

kind: Pod   
apiVersion: v1    
metadata: 
   name: hello
   labels:
     app: hello     
spec:
   containers:
   - name: hello   
     image: mylandmarktech/hello  
     ports: 
---
kind: Service  
apiVersion: v1  
metadata:
  name: hellosvc    
spec:
   type: ClusterIP    
   selector:   
      app: hello     
   ports:                                                                              
   - port: 80           
     targetPort: 80        

**********************************************************************
ubuntu@master:~$ kubectl apply -f manifest/
pod/hello unchanged
service/hellosvc created
ubuntu@master:~$ kubectl get all 
we see both opd n service 
ubuntu@master:~$  kubectl get events        38:00
with the help of the container runtime, w esee it created n started the container  

kubectl get svc -n dev  
kubectl describe svc  
kubectl get ep  
kubectl describe svc   
kubectl delete svc

What is FQDN?
FQDN = Fully Qualified Domain name. 
If one POD need to access service & which are in different names space 
we have to use the FQDN of the service.
Syntax: <serivceName>.<namespace>.svc.cluster.local
ex: myappsvc.dev.svc.cluster.local

curl hellosvc.dev.svc.cluster.local

serviceNAME  = hellosvc   
service FQDN = hellosvc.dev.svc.cluster.local

kubectl run web --image=mylandmarktech/java-web-app --port=8080 -n default  


IQ: what is Static Pods ?
    Static Pods are controlled by the kubelet service  

sudo vi /etc/kubernetes/manifests/file.yml 
kind: Pod    
apiVersion: v1   
metadata: 
   name: myapp 
   namespace: dev  
spec:   
   containers:
      - name: myapp   
        image: mylandmarktech/java-web-app   
        ports:
        - containerPort: 8080   
---
NB:
We should not create pods directly to deploy applications.
If a node  goes down in which pods are running, Pods will not be rescheduled.
We have to create pods using controllers which manages the POD life cycle.

controllerManagers:
  ReplicationControllers 
  ReplicaSets, 
  Deployments, 
  DaemonSets  

A workload is an application running on Kubernetes consisting of a single 
component or several components that work together inside a set of pods. 
In Kubernetes, a Pod represents a set of running containers on your cluster.

Kubernetes pods have a defined lifecycle. 
For example, once a pod is running in your 
cluster and the node hosting the pod fails then pods running on the node
will fail. Kubernetes treats that level of failure as final. 
You would need to create a new Pod to recover,even if the node later becomes healthy.

ReplicationControllers = rc 
=========================== kams 
kind: ReplicationController
apiVersion: v1   
metadata:  
   name: apprc 
   namespace: dev   
   labels:
      app: apprc  
spec:
   selector:
      app: web  
   replicas: 3    
   template:  #podTemplate  
      metadata: 
         name: webapp 
         labels: 
           app: web    
      spec:
         containers:
         - name: app  
           image: mylandmarktech/java-web-app
           ports:
           - containerPort: 8080 
---
kind: Service  
apiVersion: v1  
metadata:
  name: webappsvc  
spec:
   type: NodePort  
   selector: 
      app: web    
   ports:
   - port: 80  
     targetPort: 8080
     nodePort: 31000 #30000-32676 

masterIP = 3.128.206.139
NODE9-IP= 3.148.106.135


labels:    app: web   = address: gra  
selectors: app: web   = address: gra  
replicas = 3  

kubectl apply -f <filename.yml>
kubectl apply -f rc.yml
kubectl get rc 
kubectl get rc -o wide  
kubectl get rc -n <namespace>
kubectl get all
kubectl scale rc <rcName> --replicas <noOfReplicas>
kubectl scale rc apprc --replicas 4  

kubectl describe rc <rcName>
kubectl delete rc <rcName>

kubectl scale  pod app --replicas 4    = NO        
kubectl scale  rc apprc --replicas 1   = YES  
kubectl scale  rc apprc --replicas 4   = YES  
kubectl delete rc apprc

1 replicas running and serving 10m requests from users    
5 replicas running and serving 50m requests from users   
spike 
  docker is use to containerise  
  kubernetes is used to Orchestrate containers  

 containers are running in pods   
 pods can be deployed/managed by using:
 1. pods as a kubernetes objects  
 2. controllerManagers kubernetes objects   
  How POD is manage  

ReplicaSet = RS :
==========
What is difference b/w replicaset and replication controller?
RS is the next generation of replication controllers 
The only difference as now is the selector support.

RC --> Supports only equality based selectors.
key == value(Equal Condition)
selector:
    app: javawebapp
    tier: fe    
    client: tesla  

RS --> Supports eqaulity based selectors and set based selectors.  
eqaulity based:
key == value(Equal Condition)  
set based:
  key in [ value1, value2, value3 ]

selector:
   matchLabels:   -# Equality Based
    key: value
    app: javawebapp
    tier: fe    
    client: tesla

   matchExpressions: -# Set Based
   - key: app
     operator: in
     values:
     - javawebpp
     - myapp  
     - fe  
rs.yml  = kams 
--------------
kind: ReplicaSet
apiVersion: apps/v1  
metadata : 
   name: rsName  
spec:
   replicas: noOfReplicas  
   selector:
      matchLabels:
         <key>: <value>
         <app>: myapp
      matchExpressions:
      - key: <key>
        operator: <in / not in>
        values:
        - <value1>
        - <value2>
        - <value3>  
   template: #PODtemplate  
     metadata:
       name: podName
       labels:
         <key1>: <value1>
         <key2>: <value2>     
     spec:  
       containers: 
       - name: <containerName>
         image: <imageName:tag>
         ports:
         - containerPort: containerPortNumber  
---
rs.yml   
kind: ReplicaSet
apiVersion: apps/v1  
metadata:
  name: pythonapprs    
spec:
  replicas: 1 
  selector:
    matchLabels:
      app: python    
  template: 
    metadata:
      name: webapp  
      labels:
        app: python  
    spec:
      containers:
      - name: web 
        image: mylandmarktech/python-flask-app:2    
        ports:
        - containerPort: 5000      
---
kind: Service  
apiVersion: v1  
metadata:
  name: pythonsvc    
spec:
   type: NodePort  
   selector: 
      app: python       
   ports:
   - port: 80  
     targetPort: 8080
     nodePort: 31100 #30000-32676 

masterIP = 3.128.206.139
NODE9-IP= 3.148.106.135

  curl 3.148.106.135:31100 

docker pull mylandmarktech/nodejs-app:2  
docker tag mylandmarktech/nodejs-app:2 mylandmarktech/nodeapp
docker push mylandmarktech/nodeapp  

node-rs.yml  
==========
kind: ReplicaSet
apiVersion: apps/v1  
metadata:
  name: node-rs    
spec:
  replicas: 1 
  selector:
    matchLabels:
      app: node       
  template: 
    metadata:
      name: nodeapp  
      labels:
        app: node    
    spec:
      imagePullSecrets:
      - name: dockerHublogin
      containers:
      - name: nodeapp  
        image: mylandmarktech/nodeapp   
        ports:
        - containerPort: 9981  
---
kind: Service  
apiVersion: v1  
metadata:
  name: nodesvc    
spec:
   type: NodePort  
   selector: 
      app: node         
   ports:
   - port: 80  
     targetPort: 9981
     nodePort: 30500   #30000-32676  
---
kubectl create secret docker-registry regcred
 --docker-server=<your-registry-server> 
 --docker-username=<your-name> 
 --docker-password=<your-pword>
 --docker-email=<your-email>


kubectl create secret docker-registry dockerhublogin \
    --docker-server=docker.io --docker-username=mylandmarktech \
    --docker-password=admin123  

 RESTFULAPIs:
   /landmarktechnologies
   /html
   /jsonData

  curl 3.148.106.135:30500/landmarktechnologies   

    curl 3.148.106.135:30500/jsonData   



   boa.com/login   
   boa.com/transfers  
   boa.com/mortgages  

apiVersion: v1
kind: Pod
metadata:
  name: private-reg
spec:
  containers:
  - name: private-reg-container
    image: <your-private-image>
  imagePullSecrets:
  - name: regcred

kubectl get rs 
kubectl get rs -n <namespace>
kubectl get rs -o wide  
kubectl get all
kubectl scale rs <rsName> --replicas <noOfReplicas>

kubectl describe rs <rsName>
kubectl delete rs <rsName>

kubectl scale rs nodeapp --replicas 3 

  landmarktechnologies

   http://34.219.16.213:31500/landmarktechnologies

    http://34.219.16.213:32000


deployment of applications using ReplicaSet in kubernetes:
ReplicaSet:
   selector:
      matchLabels:
         app:  node    
   template:
      metadata:
         name: webapp  
         labels:
            app: node  
      spec:
         containers: 
         - name: webapp  
           image: mylandmarktech/hello  
           ports: 
           - containerPort: 80  
---
spec:
   type: NodePort  
   selector:
      app: node   


DaemonSet:
==========
https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
