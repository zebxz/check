1:27 ........we studied devops with aws, linux and k8

ubuntu@master:~$ kubectl get po 

----
kubectl config set-context --current --namespace=dev

kubectl get all
kubectl get events
kubectl delete all --all 
kubectl delete all --all -n dev     
kubectl delete pod --all
kubectl get pods 
kubectl get pods -o yaml  
kubectl get pods --show-labels
kubectl get pods -o wide
kubectl get pods -o wide --show-labels

kubectl  describe pod <podName>
kubectl  describe pod <podName> -n <namespace>

kubectl run app --image=mylandmarktech/hello --port=80

hello.yml  
=========   kams  
kind: Pod   
apiVersion: v1    
metadata: 
   name: hello
   labels:
     app: hello     
spec:
   containers:
   - name: hello   
     image: mylandmarktech/hello  
     ports:
     - containerPort: 80  

kubectl api-resources | grep pod  

ServiceDicovery:
===============
ClusterIP is the default kubernetes service type that support
communication within the cluster. 

POD=labels:
  app: hello     
Serice = selectors:  
   app: hello  

kubernetes Service:
  In Kubernetes Service makes our pods accessible/discoverable 
  within the cluster or exposing them outside  the cluster.
  service will identify pods using it's labels And Selector. 
  Whenever we create a service a ClusterIP (virtual IP) Address 
  will be allocated for that serivce and DNS entry will be created for that IP.
  So internally we can access using service name(DNS).

hellosvc.yml  
=========== kams   
kind: Service  
apiVersion: v1  
metadata:
  name: hellosvc  
spec:
   type: ClusterIP  
   selector: 
      app: hello  
   ports:
   - port: 80  
     targetPort: 80  


50 landmark drive Dallas

10 landmark drive Dallas

kubectl get svc -n <namespace>
kubectl get svc -n dev  
kubectl describe svc  
kubectl get ep  
kubectl describe svc   
kubectl delete svc

What is FQDN?
FQDN = Fully Qualified Domain name. 
If one POD need to access service & which are in different names space 
we have to use the FQDN of the service.
Syntax: <serivceName>.<namespace>.svc.cluster.local
ex: myappsvc.dev.svc.cluster.local

curl hellosvc.dev.svc.cluster.local

serviceNAME  = hellosvc   
service FQDN = hellosvc.dev.svc.cluster.local

kubectl run web --image=mylandmarktech/java-web-app --port=8080 -n default  


IQ: what is Static Pods ?
    Static Pods are controlled by the kubelet service  

sudo vi /etc/kubernetes/manifests/file.yml 
kind: Pod    
apiVersion: v1   
metadata: 
   name: myapp 
   namespace: dev  
spec:   
   containers:
      - name: myapp   
        image: mylandmarktech/java-web-app   
        ports:
        - containerPort: 8080   
---
NB:
We should not create pods directly to deploy applications.
If a node  goes down in which pods are running, Pods will not be rescheduled.
We have to create pods using controllers which manages the POD life cycle.

controllerManagers:
  ReplicationControllers 
  ReplicaSets, 
  Deployments, 
  DaemonSets  

A workload is an application running on Kubernetes consisting of a single 
component or several components that work together inside a set of pods. 
In Kubernetes, a Pod represents a set of running containers on your cluster.

Kubernetes pods have a defined lifecycle. 
For example, once a pod is running in your 
cluster and the node hosting the pod fails then pods running on the node
will fail. Kubernetes treats that level of failure as final. 
You would need to create a new Pod to recover,even if the node later becomes healthy.

ReplicationControllers = rc 
=========================== kams 
kind: ReplicationController
apiVersion: v1   
metadata:  
   name: apprc 
   namespace: dev   
   labels:
      app: apprc  
spec:
   selector:
      app: web  
   replicas: 3    
   template:  #podTemplate  
      metadata: 
         name: webapp 
         labels: 
           app: web    
      spec:
         containers:
         - name: app  
           image: mylandmarktech/java-web-app
           ports:
           - containerPort: 8080 
---
kind: Service  
apiVersion: v1  
metadata:
  name: webappsvc  
spec:
   type: NodePort  
   selector: 
      app: web    
   ports:
   - port: 80  
     targetPort: 8080
     nodePort: 31000 #30000-32676 

masterIP = 3.128.206.139
NODE9-IP= 3.148.106.135


labels:    app: web   = address: gra  
selectors: app: web   = address: gra  
replicas = 3  

kubectl apply -f <filename.yml>
kubectl apply -f rc.yml
kubectl get rc 
kubectl get rc -o wide  
kubectl get rc -n <namespace>
kubectl get all
kubectl scale rc <rcName> --replicas <noOfReplicas>
kubectl scale rc apprc --replicas 4  

kubectl describe rc <rcName>
kubectl delete rc <rcName>

kubectl scale  pod app --replicas 4    = NO        
kubectl scale  rc apprc --replicas 1   = YES  
kubectl scale  rc apprc --replicas 4   = YES  
kubectl delete rc apprc

1 replicas running and serving 10m requests from users    
5 replicas running and serving 50m requests from users   
spike 
  docker is use to containerise  
  kubernetes is used to Orchestrate containers  

 containers are running in pods   
 pods can be deployed/managed by using:
 1. pods as a kubernetes objects  
 2. controllerManagers kubernetes objects   
  How POD is manage  

ReplicaSet = RS :
==========
What is difference b/w replicaset and replication controller?
RS is the next generation of replication controllers 
The only difference as now is the selector support.

RC --> Supports only equality based selectors.
key == value(Equal Condition)
selector:
    app: javawebapp
    tier: fe    
    client: tesla  

RS --> Supports eqaulity based selectors and set based selectors.  
eqaulity based:
key == value(Equal Condition)  
set based:
  key in [ value1, value2, value3 ]

selector:
   matchLabels:   -# Equality Based
    key: value
    app: javawebapp
    tier: fe    
    client: tesla

   matchExpressions: -# Set Based
   - key: app
     operator: in
     values:
     - javawebpp
     - myapp  
     - fe  
rs.yml  = kams 
--------------
kind: ReplicaSet
apiVersion: apps/v1  
metadata : 
   name: rsName  
spec:
   replicas: noOfReplicas  
   selector:
      matchLabels:
         <key>: <value>
         <app>: myapp
      matchExpressions:
      - key: <key>
        operator: <in / not in>
        values:
        - <value1>
        - <value2>
        - <value3>  
   template: #PODtemplate  
     metadata:
       name: podName
       labels:
         <key1>: <value1>
         <key2>: <value2>     
     spec:  
       containers: 
       - name: <containerName>
         image: <imageName:tag>
         ports:
         - containerPort: containerPortNumber  
---
rs.yml   
kind: ReplicaSet
apiVersion: apps/v1  
metadata:
  name: pythonapprs    
spec:
  replicas: 1 
  selector:
    matchLabels:
      app: python    
  template: 
    metadata:
      name: webapp  
      labels:
        app: python  
    spec:
      containers:
      - name: web 
        image: mylandmarktech/python-flask-app:2    
        ports:
        - containerPort: 5000      
---
kind: Service  
apiVersion: v1  
metadata:
  name: pythonsvc    
spec:
   type: NodePort  
   selector: 
      app: python       
   ports:
   - port: 80  
     targetPort: 8080
     nodePort: 31100 #30000-32676 

masterIP = 3.128.206.139
NODE9-IP= 3.148.106.135

  curl 3.148.106.135:31100 

docker pull mylandmarktech/nodejs-app:2  
docker tag mylandmarktech/nodejs-app:2 mylandmarktech/nodeapp
docker push mylandmarktech/nodeapp  

node-rs.yml  
==========
kind: ReplicaSet
apiVersion: apps/v1  
metadata:
  name: node-rs    
spec:
  replicas: 1 
  selector:
    matchLabels:
      app: node       
  template: 
    metadata:
      name: nodeapp  
      labels:
        app: node    
    spec:
      imagePullSecrets:
      - name: dockerHublogin
      containers:
      - name: nodeapp  
        image: mylandmarktech/nodeapp   
        ports:
        - containerPort: 9981  
---
kind: Service  
apiVersion: v1  
metadata:
  name: nodesvc    
spec:
   type: NodePort  
   selector: 
      app: node         
   ports:
   - port: 80  
     targetPort: 9981
     nodePort: 30500   #30000-32676  
---
kubectl create secret docker-registry regcred
 --docker-server=<your-registry-server> 
 --docker-username=<your-name> 
 --docker-password=<your-pword>
 --docker-email=<your-email>


kubectl create secret docker-registry dockerhublogin \
    --docker-server=docker.io --docker-username=mylandmarktech \
    --docker-password=admin123  

 RESTFULAPIs:
   /landmarktechnologies
   /html
   /jsonData

  curl 3.148.106.135:30500/landmarktechnologies   

    curl 3.148.106.135:30500/jsonData   



   boa.com/login   
   boa.com/transfers  
   boa.com/mortgages  

apiVersion: v1
kind: Pod
metadata:
  name: private-reg
spec:
  containers:
  - name: private-reg-container
    image: <your-private-image>
  imagePullSecrets:
  - name: regcred

kubectl get rs 
kubectl get rs -n <namespace>
kubectl get rs -o wide  
kubectl get all
kubectl scale rs <rsName> --replicas <noOfReplicas>

kubectl describe rs <rsName>
kubectl delete rs <rsName>

kubectl scale rs nodeapp --replicas 3 

  landmarktechnologies

   http://34.219.16.213:31500/landmarktechnologies

    http://34.219.16.213:32000


deployment of applications using ReplicaSet in kubernetes:
ReplicaSet:
   selector:
      matchLabels:
         app:  node    
   template:
      metadata:
         name: webapp  
         labels:
            app: node  
      spec:
         containers: 
         - name: webapp  
           image: mylandmarktech/hello  
           ports: 
           - containerPort: 80  
---
spec:
   type: NodePort  
   selector:
      app: node   


DaemonSet:
==========
https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
