deployment as an object

Deployments  
==========
Deployment is a kubernetes object. 
k8 objects are used to run workloads in k8
Deployment is the recommended kubernetes object for deploying applications,  
running workloads and managing/contolling pods in our environment.   

Advantages:
     Deploy/rollout a RS.
     Updates pods (PodTemplateSpec).
     Rollback to older Deployment versions.
     Scale Deployment up or down.
     Pause and resume the Deployment.
     Use the status of the Deployment to determine state of replicas.
     Clean up older RS that you donâ€™t need anymore.
---
e.g we create a deployment called webapp and say that replica is 2
with deployment as an object :2 rplicas of the appl wil b deployed &2pods for d webapp  &when an update is done ie verson2, the update is deployed wit a new set of 2replicas
and new pods but the previous replicas will be zero (0) and 0 pods but the webapp versions still exists, this is the same process for each version that is rolled out and so
we can easily delelete or roll back to a previous set bc their replica sets were recorded
---
#### i can use IDES to generate a file and just copy then jst use what i nid v... integrated development env
*****strategy can be rolling update or recreate... 
rolling update is the default startegy  so if u dnt enter a strategy, it wil be uisng rolling update
also if w dnt define replica only 1 replica will be created
------------------------------------
kind: Deployment   
apiVersion: apps/v1    
metadata:
  name: <deploymentName> 
  labels:
    <key>: <value> 
spec:
  strategy:
    rollingUpdates   
    recreate  
  selector:
    matchLabels:
      <key>: value           
    matchExpressions:
    - key: <key>
      operator: <in /not in>  
      values: 
      - <value1> 
      - <value3>      
  template:
    metadata:
      name: podName  
    labels:
      <key>: <vales>  
    spec:
      containers:
      - name: containerName
---
---==----------------------we are nt passing strategy bc we want the default strategy to be sused and we didnt nt define replica too
vi apps.yml

deploy.yml   
===========
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
spec:
  selector:
    matchLabels:
      app: myapp
  template:
    metadata:
      labels:
        app: myapp
    spec:
      containers:
      - name: myapp
        image: mylandmarktech/hello:1    
        ports:
        - containerPort: 80

kind: Service
apiVersion: v1
metadata:
  name: appsvc
spec:
  selector:
    app: myapp
  type: NodePort
  ports:
  - port: 80
    targetPort: 80
    nodePort: 31400 #[30000-32676]

**************kubectl apply -f deploy/ ...... to deploy the file  ......................   .21:33
ubuntu@master:~ kubectl apply -f deploy/
deployment.apps/myapp created
service/appsvc created
ubuntu@master:~ 
ubuntu@master:~ kubectl get deploy 
ubuntu@master:~ kubectl describe deploy   ..... we can see 1replica created and strategy type: RollingUpdate
ubuntu@master:~ kubectl get svc........we can see the appsvc service routing service to the backend application
and we can access the appl online 
ubuntu@master:~ kubectl scale deployment myapp --replicas 2    



what is the default deployment strategy?
  RollingUpdates  

kubectl scale deployment <deploymentName> --replicas <noOfReplicas>
kubectl scale deployment myapp --replicas 2    

Deployment strategies:
====================== ..........................  ******************       25:33
ReCreate strategy  --- 
  It comes with downtime because the current application version is destroy entirely
  before creating the new version  

   8 pods of version1 running and you want to 
   deploy 8 pods of version2 , recreate will first destroy all the 8pods of the current version
therfore ther will be downtime
-------------------
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
spec:
  replicas: 4
  strategy:
    type: Recreate
  selector:
    matchLabels:
      app: myapp
  template:
    metadata:
      labels:
        app: myapp
    spec:
      containers:
      - name: myapp
        image: mylandmarktech/hello:1    
        ports:
        - containerPort: 80
---
kind: Service
apiVersion: v1
metadata:
  name: appsvc
spec:
  selector:
    app: myapp
  type: NodePort
  ports:
  - port: 80
    targetPort: 80
    nodePort: 31400 #[30000-32676]

---
ubuntu@master:~ kubectl apply -f deploy/
deployment.apps/myapp configured
service/appsvc unchanged
ubuntu@master:~  kubectl get deploy  ......... we see 4replicas running
ubuntu@master:~ kubectl describe deploy myapp  ... and the strategy type is recreate
we can also access it online
we can also deploy version2 but der wil be some downtime bc all the applications will go offline


# Create Deployment
kubectl create deployment <deployment-Name> --image=<Container-Image>
kubectl create deployment my-first-deployment --image=mylandmarktech/hello

##### but since we are using apply:
kubectl apply -f deploy/app.yml  

# Verify Deployment
kubectl get deployments
kubectl get deploy 

# Describe Deployment
kubectl describe deployment <deployment-name>
kubectl describe deploy deploymentname    

# Verify ReplicaSet
kubectl get rs

# Verify Pod
kubectl get po

Scaling a Deployment
====================
# Scale Up the Deployment
kubectl scale --replicas=20 deployment/<Deployment-Name>
kubectl scale --replicas=20 deployment/myapp 

# Verify Deployment
kubectl get deploy

# Verify ReplicaSet
kubectl get rs

# Verify Pods
kubectl get po

# Scale Down the Deployment
kubectl scale --replicas=2 deployment/myapp  
kubectl get deploy

### Expose Deployment as a Service
we can expose by creating the service
==============================
---     we were able to create a service lik ethis for our deployment
kind: Service
apiVersion: v1
metadata:
  name: appsvc
spec:
  selector:
    app: myapp
  type: NodePort
  ports:
  - port: 80
    targetPort: 80
    nodePort: 31400 #[30000-32676]

RollingUpdates strategy:   no downtime 
-# Deployment RollingUpdate
---------------------
vi ru.yml and paste

kind: Deployment
apiVersion: apps/v1
metadata:
  name: web
spec:
  replicas: 2
  selector:
    matchLabels:
      app: hello
  strategy:
    type: RollingUpdate
    rollingUpdate:
       maxSurge: 1   ****************** ie the max number of pod that can b
       maxUnavailable: 1
  minReadySeconds: 30   
  selector:
    matchLabels:
      app: myapp 
  template:
    metadata:
      name: hello
      labels:
        app: myapp
    spec:
      containers:
      - name: helloworld
        image: mylandmarktech/hello:1
        ports:
        - containerPort: 80

Update Deployments
Introduction
    We can update deployments using two options
        Set Image
        Edit Deployment

# Update Deployment - SHOULD WORK NOW
kubectl set image deploy Deployment-Name> <Container-Name>=<Container-Image> --record=true
kubectl set image deploy web helloworld=mylandmarktech/hello:2 --record=true

Rollback to previous version
============================
# Undo Deployment
kubectl rollout undo deployment/web  

# List Deployment Rollout History
kubectl rollout history deployment/web    

Blue Green deployment Technique : 
   version1/blue running in production
   version2/green deployed in production  
   we deploy version2 in the test environment and observe its performance 
   Once the performance is good then we deploy version2/green in production          

Canary deployment Technique : 
   - TRAFFIC MGT   
   - 25% traffic VERSION2 goes to Canada  
   - 75% traffic VERSION1 goes to USA  
   - VERSION1 -- 40% to version1   
   - VERSION2 -- 60% to version2           
   - 40years+   75% traffic VERSION1
   - 18-39years 25% traffic VERSION2




Ticket 007:
  Setup a multi nodes kubernetes cluster using the kops software.

Ticket 017:
  Setup a kubernetes cluster using the amazon EKS? .

Ticket 019:
  Instal tree, unzip, git and nano in a windows system and an ubuntu.

kubernetes 3 Video
====================   
Imparative approach - Pods/Deployments  
Delarative approach - Pods/ReplicationControllers
ClusterIP and NodePort Services
Jan 28, 2024  
 
