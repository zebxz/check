kub1&2


kubeadm --> We can setup multi node k8's cluster using kubeadm.  ... kubeasm is a sfware that is used to launch a k8, both d control plane n worker node
    kubespray --> We can setup multi node k8s cluster using kubespray , it uses ansible playbook
     (Ansible Playbooks Used internally by kubespray).
  
first instal container-d n its dependecies bc our runtime (to b able to start&runour conatiners) is nt docker bt it is container
-d, once it is installed, we will proceed to start container-d  afterwhcih we wil instal kublet, kubeabm and kubectl,, after that we wil start the kublet
service i will run this as a script and i nid to be root user

Initialize Kubernetes control plane by running the below commond as root user.
sudo kubeadm init

run the 3commands as stated in the success notification in my cli  (mkdir -p $HOME/.kube .......)
we can cat .kube/config  file, we can see its content n this is d file authenticating us to carry out tasks and d  user now is the admin , so he has admin
access in d  cluster

we run : kubectl get node  or kubectl get pod
it shows the master node is not ready
7) so to ensure its ready we v to deploy the ntwrk plugging
kubectl apply -f https://github.com/weaveworks/weave/releases/download/v2.8.1/weave-daemonset-k8s.yaml
************now it has created certain components 
now if we execute kubectl get node .............. our master node is ready

lets check all the pods in the cluster ..... kubectl -A 





advantages of namespace
****clusterRole &clusterRolebinding is for the entire cluster 

***Docker is 'compose file'  deploy with command 'Docker compose up -d' WHILE kubernetes is 'manifest file' deployed with command 'kubectl apply -f pod.yml'


   TK NOTE OF THIS TREE
kubernetes:    kub has a cluster , 
   cluster: it is a grp of nodes
   nodes:  in the nodes ther are pods 
   pods:  in the pods ther ar containers ..  
   containers :  


        OBJECTS USED FOR DEPLOYMENT
kubernetes resources/objects used to deploy application include:
   Pod :
or    
 controllerManagers:
      Replication Controller
      ReplicaSet
      DaemonSet
      StatefulSets
      Deployment
      Volume
      Job       

****when u deploy appl in k8, u v to make the appl accessible ie exposing appl/accessing appl
Exposing/accessing applications = Service Discovery:
    Service Types:  it will route service to our appl n their replicas ,
    ClusterIP :  it performs LB  , its used for internal communication inside the cluster.
    NodePort
    LoadBalancer
    ExternalName  
  ingress 
  networkPolicy 




  KEY VALUE PAIR
hw do we consider keyvalue pair 
**************for e.g when u want to create a manifest file, it has this acronym, comes :   where 'comes' stands for kind, api version, metadata and spec
kind is a key value pair bc for example ; kind is pod , this is a key value pair, it has a key & a value  ,,, so key &value ,, kind:pod
for e.g , key value pair could be  name and the value is simon
key:value  pairs 
name: simon   



kubectl get namespace
  kubectl get ns 

 kubectl create namespace fintech --v=8      . V , MEANS   in verbose
 kubectl create namespace dev     
 kubectl delete namespace dev


How to deploy run/execute tasks/workloads in kubernetes??
   1. Imperative  approach 
        By using commands 

   2. Declarative approach
        By using files [manifests files]  

-# Create POD Using Command
kubectl run <podName> --image=<imageName> --port=<containerPort> -n <namespaceName>
kubectl run hello --image=mylandmarktech/hello --port=80 -n dev 


ubuntu@master:~$  kubectl get po    ...... ........      ****By default, it lists pods in the currently configured namespace.
no resources found in default namespace 
ubuntu@master:~$ kubectl get po -n dev
no resources found in dev namespace 

ubuntu@master:~$ kubectl get svc -n dev      .... to check for services
no resources found in dev namespace 

To deploy manifest file
vi pod.yml and paste the mainfest file 
kubectl apply -f pod.yml


kub 3&4

 MORE PODS COMMANDS ............7:25
kubectl get all
kubectl get events
kubectl delete po (podname)
kubectl delete all --all 
kubectl delete all --all -n dev     
kubectl delete pod --all                                                                                               interpretin , creatin &mangin d pod 
kubectl get pods                               Anotation is a metadata info abt ur pod that is set by d sys/k8 service n it is what d sys wil understan when it comes to
kubectl get pods -o yaml   ...   will present the pod in that are runnin in our clustera yml file, we can see annotation,bt when we made d file to create d pod der was no anotation
kubectl get pods --show-labels
kubectl get pods -o wide           **************** gives more inf abt the pods
kubectl get pods -o wide --show-labels
kubectl get node
kubectl get node -o wide    *************** we see d nodes we v , the k8 version, the kernel version and the runtime which is containerd and not docker .(tk note)
kubectl delete node node5   ******************* to delete node5

in docker we run: docker inspect  to get more info abt the container
kubectl  describe pod <podName>      *********to get more info abt the pod 
kubectl  describe pod <podName> -n <namespace>


kubectl api-resources   *********** to get the apiresources for our pod,, we can see so many api resources , ...
kubectl api-resources | grep pod      ....  so to specify n grep for pod , we see we can either call it pods or po and the apiversion is v1



We can check the service 
   Kubectl  get svc 

To get the end point 
Kubectl get ep

Kubectl  get svc â€“o wide

kubectl get svc -n <namespace>       (svc is service)
kubectl get svc -n dev  


kubectl get svc -n dev  
kubectl describe svc  
kubectl get ep      ... we can get the end point.. one/ A single service can route traffic/LB to multiple replicas of an appl  43:20
kubectl describe svc     gives more info abt the service
kubectl delete svc



FQDN
If one POD need to access service & which are in different names space 
we have to use the FQDN of the service.
******************Syntax: <serivceName>.<namespace>.svc.cluster.local
                 ex: myappsvc.dev.svc.cluster.local


creating static pod
sudo vi /etc/kubernetes/manifests/file.yml            ************we ar creating it in the k8 manifest dir


REPLICA CONTROLLERS
 kubectl get rc
 kubectl describe rc apprc       ..... to see more info     ***i bliv 'apprc' is the rc' label




 ##########more COMMANDS FOR REPLICATOR CONTROLLERS
labels:    app: web   = address: gra  
selectors: app: web   = address: gra  
replicas = 3  

kubectl apply -f <filename.yml>
kubectl apply -f rc.yml
kubectl get rc 
kubectl get rc -o wide  
kubectl get rc -n <namespace>
kubectl get all
kubectl scale rc <rcName> --replicas <noOfReplicas>   ..     **************** ..... WE CAN ASLO SCALE the replication controller 

kubectl scale rc apprc --replicas 4     
kubectl describe rc <rcName>
kubectl delete rc <rcName>



  CREATE SECRET
Create a secret that will authenticate kubernetes to pull images from dockerHub/nexus/jfrog  
dockerHublogin
kubectl create secret docker-registry regcred     ...****************** docker-registry is the name of the secret which we call regcred 
 --docker-server=<your-registry-server>  docker.io
 --docker-username=<your-name>  mylandmarktech
 --docker-password=<your-pword>   admin123
 --docker-email=<your-email>     ********************************can enter email but without email it will work

kubectl create secret docker-registry dockerhublogin \             **************      we called it dockerhublogin
    --docker-server=docker.io --docker-username=mylandmarktech \
    --docker-password=admin123  

ubuntu@master:~$ kubectl get secret
and now i can see the secret    .... now i can pull images
ubuntu@master:~$    kubectl describe secret dockerhublogin
i can also dercribe the secret



KUB 5 ... CLASS34

kubectl delete rs --all
kubectl delete svc --all
kubectl delete all -all

kubectl get ds       GET Daemon set

TAINTING NODE
ubuntu@master:~$ kubectl taint nodes node1 key1=value1:NoSchedule ...... am  tainting this node wit no schedule which means pod cannot be scheduled on the node  ...1:35:55
for  a pod to be scheduled on the tainted node we nid to add tolerations in the spec:



KUB 6   
Deployment 

kubectl get deploy 
ubuntu@master:~ kubectl describe deploy   ..... we can see 1replica created and strategy type: RollingUpdate
ubuntu@master:~ kubectl get svc........we can see the appsvc service routing service to the backend application
and we can access the appl online 
ubuntu@master:~ kubectl scale deployment myapp --replicas 2    


kubectl scale deployment <deploymentName> --replicas <noOfReplicas>
kubectl scale deployment myapp --replicas 2    



# Create Deployment
kubectl create deployment <deployment-Name> --image=<Container-Image>
kubectl create deployment my-first-deployment --image=mylandmarktech/hello

##### but since we are using apply:  ** i bliv it means using declarative approach ie manifest file
kubectl apply -f deploy/app.yml  

# Verify Deployment
kubectl get deployments
kubectl get deploy 

# Describe Deployment
kubectl describe deployment <deployment-name>
kubectl describe deploy deploymentname    

# Verify ReplicaSet
kubectl get rs

# Verify Pod
kubectl get po

Scaling a Deployment
====================
# Scale Up the Deployment
kubectl scale --replicas=20 deployment/<Deployment-Name>
kubectl scale --replicas=20 deployment/myapp 

# Verify Deployment
kubectl get deploy

# Verify ReplicaSet
kubectl get rs

# Verify Pods
kubectl get po

# Scale Down the Deployment
kubectl scale --replicas=2 deployment/myapp  
kubectl get deploy


# Update Deployment -uusing set image  SHOULD WORK NOW
kubectl set image deploy Deployment-Name> <Container-Name>=<Container-Image> --record=true
kubectl set image deploy web helloworld=mylandmarktech/hello:2 --record=true

Rollback to previous version
============================
# Undo Deployment
kubectl rollout undo deployment/web  

# List Deployment Rollout History
kubectl rollout history deployment/web  
